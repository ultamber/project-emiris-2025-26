# Αναφορά Αποτελεσμάτων Πειραμάτων ANN - MNIST FILES

## Επισκόπηση

Τα αποτελέσματα αφορούν συγκριτική αξιολόγηση αλγορίθμων **Approximate Nearest Neighbor (ANN)** για εύρεση κοντινών γειτόνων σε υψηλής διάστασης διανύσματα.
Το συγκεκριμένο αρχείο αφορά τα αποτελέσματα των runs που εκτελέστηκαν με είσοδο MNIST αρχεία .

| Αλγόριθμος | Κύριες Παράμετροι | Μετρικές Απόδοσης |
|-------------|------------------|-------------------|
| **LSH** | `k`, `L`, `w`, `seed` | AF (Approximation Factor), Recall, QPS, tApprox, tTrue |
| **Hypercube** | `kproj`, `M`, `probes` | AF, Recall, QPS, tApprox, tTrue |
| **IVFFlat** | `kclusters`, `nprobe` | AF, Recall, QPS , tApprox, tTrue |
| **IVFPQ** | `kclusters`, `nprobe`, `M`, `nbits` | AF, Recall, QPS , tApprox, tTrue |

---

## 1. LSH (Locality Sensitive Hashing)

### Γενικές Τάσεις
- Η αύξηση του **`w`** (εύρος hash) **βελτιώνει σημαντικά το Recall**, αλλά μειώνει την ταχύτητα (QPS).  
- Η αύξηση του **`L`** (αριθμός πινάκων hash) **βελτιώνει το Recall**, αλλά με μεγαλύτερο υπολογιστικό κόστος.  
- Η αύξηση του **`k`** μειώνει το Recall αλλά αυξάνει την επιλεκτικότητα (λιγότερες συγκρούσεις).  
- Το **`seed`** έχει αμελητέα επίδραση στα αποτελέσματα.

### Απόδοση ανά `w`

| w | Recall (τυπικό εύρος) | QPS (τυπικό εύρος) | AF | Παρατηρήσεις |
|---|-----------------------|--------------------|----|---------------|
| **2.0** | 0.02 – 0.45 | 100 – 9000 | 1.1 – 1.6 | Πολύ γρήγορο αλλά χαμηλό Recall |
| **4.0** | 0.25 – 0.85 | 30 – 2200 | 1.0 – 1.2 | Ισορροπία ταχύτητας και ακρίβειας |
| **6.0** | 0.30 – 0.96 | 15 – 600 | 1.0 – 1.1 | Υψηλή ακρίβεια, χαμηλότερη ταχύτητα |
| **8.0** | 0.67 – 0.99 | 9 – 250 | 1.00 – 1.05 | Σχεδόν ακριβής αναζήτηση |

#### Βέλτιστη Ισορροπία
- `w = 4`, `k = 2–3`, `L = 10–15`  
  ➜ Recall ≈ 0.7–0.85, AF ≈ 1.05, QPS ≈ 40–200  

#### Ταχύτερη Ρύθμιση
- `w = 2`, `k = 4`, `L = 5` ➜ QPS ≈ 9000, αλλά Recall < 0.1  

#### Πιο Ακριβής Ρύθμιση
- `w = 8`, `k = 2`, `L = 15` ➜ Recall ≈ 0.99, AF ≈ 1.0002, QPS ≈ 9–30  

---

## 2. Hypercube

### Παρατηρήσεις
- Recall ≈ 0.10 – 0.23  
- AF ≈ 1.15 – 1.25  
- QPS ≈ 600 – 1300 (σταθερό και σχετικά υψηλό)  
- Περισσότερα **probes** αυξάνουν ελαφρά το Recall, αλλά με φθίνουσα απόδοση.
 **Συμπέρασμα:**  
Ο Hypercube επιτυγχάνει **μέτρια ακρίβεια με σταθερή ταχύτητα**.  
Ιδανικός για εφαρμογές όπου προτιμάται σταθερό throughput αντί για υψηλή ακρίβεια.

---

## 3. IVFFlat

### Παρατηρήσεις
- Recall ≈ 0.98 – 1.00 → **σχεδόν ακριβής αναζήτηση**  
- AF ≈ 1.000 – 1.001  
- QPS ≈ 9 – 16 → **πιο αργό** από τις προσεγγιστικές μεθόδους  
- Η αύξηση του `nprobe` αυξάνει το Recall αλλά μειώνει την ταχύτητα.

#### Ενδεικτικές ρυθμίσεις
- `kclusters = 64–128`, `nprobe = 8–16`  
  ➜ Recall ≈ 0.999–1.000, QPS ≈ 10–12  
 **Ιδανικό για:** περιπτώσεις όπου απαιτείται **υψηλή ακρίβεια ή αναζήτηση σχεδόν ακριβείας**.

---

## 4. IVFPQ (Inverted File with Product Quantization)

### Παρατηρήσεις
- Recall ≈ 0.97 – 0.99  
- AF ≈ 1.000 – 1.001  
- QPS ≈ 300 – 700 → **πολύ υψηλή ταχύτητα**  
- Ελάχιστη απώλεια ακρίβειας σε σχέση με IVFFlat.

####  Ερμηνεία:
Ο IVFPQ προσφέρει **την καλύτερη σχέση ακρίβειας/ταχύτητας**.

 Παράδειγμα:
- `IVFPQ, kclusters=50, nprobe=8, M=8, nbits=8`  
  ➜ Recall ≈ 0.9948, AF ≈ 1.0002, QPS ≈ 322  
  ➜ **Πολύ γρήγορος** με σχεδόν πλήρη ακρίβεια.

---

##  5. Συγκριτικός Πίνακας

| Αλγόριθμος | Recall (Ακρίβεια) | AF | QPS (Ταχύτητα) | Κατάλληλος για |
|-------------|-------------------|----|----------------|----------------|
| **LSH** | 0.02 – 0.99 | 1.0 – 1.6 | 10 – 9000 | Ρυθμιζόμενη ακρίβεια, πειράματα ταχύτητας |
| **Hypercube** | 0.10 – 0.23 | 1.15 – 1.25 | 600 – 1300 | Μέση ακρίβεια, σταθερή απόδοση |
| **IVFFlat** | 0.98 – 1.00 | 1.000 – 1.001 | 9 – 16 | Ακριβής ή σχεδόν ακριβής αναζήτηση |
| **IVFPQ** | 0.97 – 0.99 | 1.000 – 1.001 | 300 – 700 | Εξαιρετική ισορροπία ακρίβειας/ταχύτητας |

---

##  6. Συμπεράσματα

1. **Σχέση ακρίβειας–ταχύτητας (trade-off):**  
   - Ο LSH καλύπτει όλο το φάσμα (από πολύ γρήγορος μέχρι πολύ ακριβής) ανάλογα με τις παραμέτρους.  
   - Ο IVFPQ υπερέχει στις πρακτικές εφαρμογές με **υψηλό Recall και πολύ καλή ταχύτητα**.

2. **Κλιμάκωση:**  
   - Ο LSH είναι κατάλληλος για μεγάλα σύνολα δεδομένων λόγω παραλληλίας.  
   - Ο IVFPQ προσφέρει συμπαγή αναπαράσταση (quantization) με εξαιρετική απόδοση.

3. **Προτεινόμενη χρήση:**  
   -  **Γρήγορη προσεγγιστική αναζήτηση:** `LSH (w=4, k=2, L=10)`  
   -  **Ισορροπία ακρίβειας/ταχύτητας:** `IVFPQ (M=8–16, nprobe=8)`  
   -  **Ακριβής αναζήτηση:** `IVFFlat (nprobe ≥ 8)`

---
